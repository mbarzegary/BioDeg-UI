load "msh3"
load "medit"
load "distance"
load "iovtk"
load "parmmg"
load "mmg"
load "mshmet"
load "tetgen"
include "getARGV.idp"

include "parameters.idp"

real sizeX; //= 16 + 10;
real sizeY; //= 16 + 10;
real sizeZ; //= 25 + 10;
real centerX; //= sizeX/2;
real centerY; //= sizeY/2;
real centerZ; //= sizeZ/2;

mesh3 Mesh;
mesh3 MeshScaffold;

MeshScaffold = readmesh3(meshFileName);
include "dimension.idp"

if (mpirank == 0)
{
  cout << "Generating mesh..." << endl;
  Mesh = cube(2, 2, 2, [sizeX*x-centerX, sizeY*y-centerY, sizeZ*z-centerZ]);
  real[int] domain = [0, 0, 0, 0, 1];
  Mesh = tetgreconstruction(Mesh, switch="raAQ", regionlist=domain,
                          sizeofvolume=(sizeX/meshSize)*(sizeY/meshSize)*(sizeZ/meshSize)/6);
}
broadcast(processor(0), Mesh);

fespace SpaceP1(Mesh, P1);
SpaceP1 phi = 0;

SpaceP1 X = x;
SpaceP1 Y = y;
SpaceP1 Z = z;

if (mpirank == 0)
{
  cout << "Processing nodes..." << endl;
  for (int i = 0; i < SpaceP1.ndof; i++)
  {
    if (chi(MeshScaffold)(X[][i], Y[][i], Z[][i]) == 1)
      phi[][i] = 1;
    cout << "\rProcessed: " << i << " / " << SpaceP1.ndof;
  }
  cout << endl;
}
broadcast(processor(0), phi[]);

phi = phi - 0.5;

if (refineMesh)
{
  if (mpirank == 0)
    cout << "Refining the mesh..." << endl;

  SpaceP1 phiTemp;
  distance(Mesh, phi, phiTemp[]);
  phi = phiTemp;

  Mesh = change(Mesh, flabel=0);
  Mesh = change(Mesh, fregion=0);

  SpaceP1 sol = 0.5 * (phi > wd) + -0.5 * (phi < -wd) + 0 * (phi >= -wd) * (phi <= wd);

  SpaceP1 met;
  met[] = mshmet(Mesh, sol, aniso=0, hmin=meshMin, hmax=meshMax, err=mshmetError);
  if (doParallel)
    Mesh = parmmg3d(Mesh, metric=met[], hausd=hausd, hgrad=hgrad, verbose=10,
                    niter=nIterations, mem=allowedMemory, comm=mpiCommWorld);
  else
    Mesh = mmg3d(Mesh, metric=met[], hausd=hausd, hgrad=hgrad, verbose=10);
  phi = phi;
}

if (writeTestVtk)
{
  if (mpirank == 0)
  {
    int[int] orderOut = [1];
    savevtk(vtkFileName, Mesh, phi, dataname="phi", order=orderOut);
  }
}

if (mpirank == 0)
{
  savesol(solFileName, Mesh, phi);
  savemesh(Mesh, outputFileName);

  cout << "Finite Element DOF: " + SpaceP1.ndof << endl;
  cout << "Number of Elements: " + Mesh.nt << endl;;
}
